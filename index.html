<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Guide Review Summary Tool</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; background: #f9f9f9; }
    h1 { margin-bottom: 1rem; }
    .controls { margin-bottom: 1rem; }
    .controls label { margin-right: 1rem; }
    #output { margin-top: 1.5rem; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 1rem; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; vertical-align: top; }
    th { background: #eee; text-align: left; }
    #downloadBtn { margin-top: 0.5rem; }
    ul { margin: 0; padding-left: 1.2rem; }
  </style>
</head>
<body>
  <h1>Guide Review Summary Tool</h1>
  <div class="controls">
    <label>Min words per review: <input type="number" id="minWords" value="5" min="1" step="1" /></label>
    <label>Similarity threshold: <input type="number" id="simThreshold" value="0.8" min="0" max="1" step="0.05" /></label>
    <input type="file" id="fileInput" accept=".csv" />
  </div>
  <div id="output"></div>
  <button id="downloadBtn" style="display:none;">Download Summary CSV</button>

  <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
  <script src="https://unpkg.com/compromise@13.11.3/builds/compromise.min.js"></script>
  <script>
    // Utility: compute similarity for clustering
    function sim(a, b) {
      if (a === b) return 1;
      let m = 0;
      const len = Math.min(a.length, b.length);
      for (let i = 0; i < len; i++) if (a[i] === b[i]) m++;
      return m / len;
    }

    // Common stopwords to exclude as names
    const stopwords = new Set([
      'the','a','and','but','then','nice','good','what','how','i','it','is','was','were','are',
      'to','of','in','that','this','for','with','you','on','as','they','be','at','or','an','by',
      'have','from','my','your','their','if','so','no','not','all','just','do','does','did','had',
      'he','she','we','our','us','me','his','her','them'
    ]);
    // Negative keywords for filtering reviews
    const negativeWords = ['bad','poor','terrible','horrible','hate','worst','awful','not','didnt','didn\'t','don\'t','never'];

    document.getElementById('fileInput').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const minWords = parseInt(document.getElementById('minWords').value, 10);
      const threshold = parseFloat(document.getElementById('simThreshold').value);

      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: ({ data, meta }) => {
          // 1. Identify review column
          const revCol = meta.fields.find(f => /review/i.test(f)) || meta.fields[0];
          // 2. Filter substantive reviews
          let subs = data.filter(r => (r[revCol] || '').trim().split(/\s+/).length > minWords);
          // 3. Filter out negative reviews
          subs = subs.filter(r => {
            const txt = (r[revCol] || '').toLowerCase();
            return !negativeWords.some(w => txt.includes(w));
          });

          // 4. Extract guide names via NER only
          const entries = subs.map(r => {
            const text = r[revCol];
            const doc = nlp(text);
            const people = doc.people().out('array');
            if (!people.length) return null;
            const fullName = people[0];
            const firstToken = fullName.split(/\s+/)[0];
            if (/^[A-Z][a-z]+$/.test(firstToken) && !stopwords.has(firstToken.toLowerCase())) {
              return { text, guide: firstToken };
            }
            return null;
          }).filter(x => x);

          // 5. Cluster spelling variants
          const counts = {};
          entries.forEach(x => counts[x.guide] = (counts[x.guide] || 0) + 1);
          const names = Object.keys(counts);
          const clusters = [];
          const labels = {};
          names.forEach(n => {
            let placed = false;
            for (const c of clusters) {
              if (sim(n.toLowerCase(), c[0].toLowerCase()) >= threshold) { c.push(n); placed = true; break; }
            }
            if (!placed) clusters.push([n]);
          });
          clusters.forEach(c => {
            const canon = c.reduce((a, b) => counts[a] >= counts[b] ? a : b);
            c.forEach(n => labels[n] = canon);
          });
          entries.forEach(x => x.canonical = labels[x.guide]);

          // 6. Aggregate & sort by review count descending
          const agg = {};
          entries.forEach(x => {
            const c = x.canonical;
            if (!agg[c]) agg[c] = { reviews: [], count: 0 };
            agg[c].reviews.push(x.text);
            agg[c].count++;
          });
          const sorted = Object.entries(agg).sort((a, b) => b[1].count - a[1].count);

          // 7. Generate highlights
          const adjectives = [
            'knowledgeable','excellent','interesting','informative','friendly','amazing',
            'fantastic','detailed','passionate','enthusiastic','attentive','professional',
            'engaging','dynamic','comprehensive','thorough','insightful','articulate',
            'patient','personable'
          ];
          sorted.forEach(([guide, obj]) => {
            const txt = obj.reviews.join(' ').toLowerCase();
            const found = adjectives.filter(a => txt.includes(a));
            if (found.length > 1) obj.highlights = 'Known for being ' + found.slice(0, -1).join(', ') + ' and ' + found.slice(-1) + '.';
            else if (found.length === 1) obj.highlights = 'Known for being ' + found[0] + '.';
            else obj.highlights = obj.reviews[0].split('. ')[0] + '.';
          });

          // 8. Render table
          const out = document.getElementById('output'); out.innerHTML = '';
          const table = document.createElement('table');
          const header = document.createElement('tr');
          ['Guide','Review Count','Highlights','Reviews'].forEach(h => { const th=document.createElement('th'); th.textContent=h; header.appendChild(th); });
          table.appendChild(header);
          sorted.forEach(([guide, obj]) => {
            const tr = document.createElement('tr');
            const tdGuide = document.createElement('td'); tdGuide.textContent = guide; tr.appendChild(tdGuide);
            const tdCount = document.createElement('td'); tdCount.textContent = obj.count; tr.appendChild(tdCount);
            const tdHigh = document.createElement('td'); tdHigh.textContent = obj.highlights; tr.appendChild(tdHigh);
            const tdRev = document.createElement('td'); const ul = document.createElement('ul');
            obj.reviews.forEach(rv => { const li=document.createElement('li'); li.textContent = rv; ul.appendChild(li); });
            tdRev.appendChild(ul); tr.appendChild(tdRev);
            table.appendChild(tr);
          });
          out.appendChild(table);

          // 9. Download CSV
          const rows = [['Guide','Review Count','Highlights','Reviews']];
          sorted.forEach(([guide, obj]) => rows.push([guide, obj.count, obj.highlights, obj.reviews.join(' | ')]));
          const csv = Papa.unparse(rows);
          const blob = new Blob([csv], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const btn = document.getElementById('downloadBtn'); btn.style.display = 'inline-block';
          btn.onclick = () => { const a=document.createElement('a'); a.href=url; a.download = 'guide_review_summary.csv'; a.click(); };
        }
      });
    });
  </script>
</body>
</html>

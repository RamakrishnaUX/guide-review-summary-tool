<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Guide Review Summary Tool</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; background: #f9f9f9; }
    h1 { color: #6a0dad; margin-bottom: 1rem; }
    #fileInput { margin-bottom: 1rem; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; }
    #downloadBtn {
      display: none;
      background: #6a0dad;
      color: white;
      border: none;
      padding: 0.6rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      margin-bottom: 1rem;
    }
    table { border-collapse: collapse; width: 100%; margin-top: 1rem; }
    th, td { border: 1px solid #ddd; padding: 0.6rem; }
    th { background: #eee; }
    th.sortable { cursor: pointer; user-select: none; }
    th .chevron { margin-left: 0.3rem; font-size: 0.8rem; vertical-align: middle; }
    th, td { text-align: left; }
    ul { margin: 0; padding-left: 1.2rem; }
  </style>
</head>
<body>
  <h1>Guide Review Summary Tool</h1>
  <input type="file" id="fileInput" accept=".csv" />
  <button id="downloadBtn">Download Summary CSV</button>
  <div id="output"></div>

  <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
  <script>
    // Utility: simple similarity
    function sim(a,b){
      if(a===b) return 1;
      let m=0, M=a.length, N=b.length, min=Math.min(M,N);
      for(let i=0;i<min;i++) if(a[i]===b[i]) m++;
      return m/min;
    }

    let lastBlobUrl = null;
    let lastAgg = null;
    let sortAsc = false;

    const fileInput = document.getElementById('fileInput');
    const downloadBtn = document.getElementById('downloadBtn');
    const output = document.getElementById('output');

    fileInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;

      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: ({ data, meta }) => {
          // 1. detect review column
          const revCol = meta.fields.find(f => /review/i.test(f)) || meta.fields[0];
          // 2. substantive filter
          let subs = data.filter(r => {
            const t = (r[revCol]||'').trim();
            return t.split(/\s+/).length > 5;
          });
          // 3. extract guide names (captialized, not dictionary words)
          const STOP = new Set([
            'The','And','But','Then','What','How','Nice','Good','Very','Would','All','Didn\'t'
          ]);
          subs = subs.map(r => {
            const t = r[revCol];
            const pat = /guide[s]?[:,\s]*([A-Z][a-z]+)/g;
            let name=null, m;
            while((m = pat.exec(t))!==null){
              if(!STOP.has(m[1])){ name=m[1]; break; }
            }
            return name ? { text: t, guide: name } : null;
          }).filter(x=>x);

          // 4. fuzzy cluster
          const counts = {};
          subs.forEach(x => counts[x.guide] = (counts[x.guide]||0)+1);
          const names = Object.keys(counts).sort();
          const clusters = [], labels = {};
          names.forEach(n => {
            let found=false;
            for(const c of clusters){
              if(sim(n, c[0])>=0.8){ c.push(n); found=true; break; }
            }
            if(!found) clusters.push([n]);
          });
          clusters.forEach(cluster => {
            const canon = cluster.reduce((a,b)=>counts[a]>=counts[b]?a:b);
            cluster.forEach(n=> labels[n]=canon);
          });
          subs.forEach(x => x.canonical = labels[x.guide]);

          // 5. aggregate
          const agg = {};
          subs.forEach(x => {
            const c = x.canonical;
            if(!agg[c]) agg[c] = { reviews: [], count: 0 };
            agg[c].reviews.push(x.text);
            agg[c].count++;
          });
          lastAgg = agg;

          renderTable();
          prepareDownload();
        }
      });
    });

    function renderTable(){
      const keys = Object.keys(lastAgg);
      // sort by review count
      keys.sort((a,b) => sortAsc
        ? lastAgg[a].count - lastAgg[b].count
        : lastAgg[b].count - lastAgg[a].count
      );
      // build HTML table
      let html = '<table><thead><tr>';
      html += '<th>Guide</th>';
      html += `<th class="sortable" id="colCount">Review Count<span class="chevron">${sortAsc?'▲':'▼'}</span></th>`;
      html += '<th>Highlights</th>';
      html += '<th>Reviews</th>';
      html += '</tr></thead><tbody>`;
      keys.forEach(guide => {
        const g = lastAgg[guide];
        // generate highlights
        const adjs = ['knowledgeable','friendly','helpful','terrific','phenomenal','amazing','excellent','great','smooth','informative','engaging'];
        const txt = g.reviews.join(' ').toLowerCase();
        const found = adjs.filter(a=>txt.includes(a));
        const highlights = found.length
          ? `Known for being ${ found.length>1
                ? found.slice(0,-1).join(', ')+' and '+found.slice(-1)
                : found[0]
            }.`
          : g.reviews[0].split('. ')[0]+'.';

        html += '<tr>';
        html += `<td>${guide}</td>`;
        html += `<td>${g.count}</td>`;
        html += `<td>${highlights}</td>`;
        html += `<td><ul>${g.reviews.map(r=>'<'+'li>'+r+'</'+'li>').join('')}</ul></td>`;
        html += '</tr>';
      });
      html += '</tbody></table>';
      output.innerHTML = html;

      // hook sort click
      document.getElementById('colCount').addEventListener('click', () => {
        sortAsc = !sortAsc;
        renderTable();
        prepareDownload(); // regenerate chevron
      });
    }

    function prepareDownload(){
      // teardown old blob
      if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
      // build CSV
      const rows = [['Guide','Review Count','Highlights','Reviews']];
      for(const guide in lastAgg){
        const g = lastAgg[guide];
        const adjs = []; // same logic as above
        const txt = g.reviews.join(' ').toLowerCase();
        // reuse adjs filter
        const hon = ['knowledgeable','friendly','helpful','terrific','phenomenal','amazing','excellent','great','smooth','informative','engaging'];
        const found = hon.filter(a=>txt.includes(a));
        const highlights = found.length
          ? `Known for being ${ found.length>1
                ? found.slice(0,-1).join(', ')+' and '+found.slice(-1)
                : found[0]
            }.`
          : g.reviews[0].split('. ')[0]+'.';
        rows.push([ guide, g.count, highlights, `"${g.reviews.join(' | ')}"` ]);
      }
      const csv = Papa.unparse(rows);
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      lastBlobUrl = URL.createObjectURL(blob);

      downloadBtn.style.display = 'inline-block';
      downloadBtn.onclick = () => {
        const link = document.createElement('a');
        link.href = lastBlobUrl;
        link.download = 'guide_review_summary.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };
    }
  </script>
</body>
</html>
